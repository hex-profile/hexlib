[EN](README.md) RU

Внешняя оболочка
================

В этом каталоге находится внешняя оболочка, которая содержит точку входа (main).

С точки входа стартует тред GUI, в котором работают:

- Внешняя оболочка, которая изолирует в себе всё, что зависит от оконной системы,
OpenGL и GLFW.
- GuiClass, который реализует чистый UI, и не зависит от OpenGL или оконной системы.

Содержимое:

* [PixelBuffer](#pixelbuffer):
буфер изображения, разделяемый между OpenGL и CUDA.
* [PixelBufferDrawing](#pixelbufferdrawing):
Рисование `PixelBuffer` на экране с помощью OpenGL.
* [WindowManager](#windowmanager):
класс, который изолирует внутри себя всё использование GLFW.
* [Порядок инициализации](#порядок-инициализации) внешней оболочки.

PixelBuffer
===========

`PixelBuffer` представляет буфер изображения, разделяемый между GRAPHICS (OpenGL)
и COMPUTE (например, CUDA).

Состояния:

* `NONE`: Исходное состояние, буфер пустой.
* `ALLOCATED`: Выделена общая память для буфера, доступен для работы с GRAPHICS.
* `COMPUTE-LOCKED`: Буфер заблокирован для COMPUTE, доступен для работы с COMPUTE.

Использование:

* Вызов `getGraphicsBuffer` возможен только в состоянии ALLOCATED.
* Вызов `getComputeBuffer` возможен только в состоянии COMPUTE-LOCKED.
* Для использования в режиме COMPUTE, буфер должен быть временно заблокирован
с использованием функций `lock` / `unlock`.

Расширения и платформы:

* Использует расширение OpenGL `glMakeNamedBufferResidentNV`.
* Поддерживает режим эмуляции на CPU (HEXLIB_PLATFORM == 0).

PixelBufferDrawing
==================

Рисование экземпляра `PixelBuffer` на экране с помощью OpenGL.
Использует особый шейдер OpenGL для чтения пикселей напрямую из памяти GPU.
Шейдер является специфичным для NVIDIA.

Компиляция и линковка шейдеров выполняется при инициализации.

* Инициализация и деинициализация: `reinit` и `deinit`.
* Отрисовка: `draw`.

WindowManager
=============

Изолирует внутри себя все зависимости от GLFW.

Оконный менеджер умеет:

- Создать окно.

- Положить пустое событие в очередь событий: `postEmptyEvent()`.
  Это нужно, чтобы асинхронно разбудить поток GUI из другого треда.

## Функции окна

- Установка контекста OpenGL: `setThreadDrawingContext`.
  Делает контекст OpenGL данного окна текущим для вызывающей нити.
  Видимо, устанавливает некую глобальную TLS-переменную OpenGL
  "текущий контекст".

- Обмен буферов: `swapBuffers`. Это переключение дабл-буфера OpenGL,
  когда клиент дорисовал и нужно переключить буфер на экране.

- Получение событий: `getEvents`. На вход опции "ждать событий"
  и "таймаут в миллисекундах". На выход: набор указателей на колбэки
  `EventReceivers`, которые он будет вызывать при получении событий
  изнутри вызова `getEvents`.

Другие функции окна:

- Установка видимости: `setVisible`.
- Проверка закрытия: `shouldContinue`.
- Получение и установка местоположения: `getWindowLocation` и
  `setWindowLocation`.
- Получение размера буфера изображения: `getImageSize`.

## Таймауты

При создании окна, реализация создаёт вспомогательный тред `TimeoutHelper`,
который необходим из-за отсутствия поддержки ожидания событий с таймаутом в GLFW.
Задача этого треда – получать и выполнять команды вида
"разбудить тред GUI через указанное количество миллисекунд".
В случае GLFW, чтобы разбудить, он кладет специальное пустое событие
в очередь событий, используя функцию `glfwPostEmptyEvent`.

## Колбеки GLFW

Всё использование GLFW, включая его колбеки, происходит в одном и том же треде GUI.
Здесь нет никакой асинхронности, кроме добавления операционной системой событий
в очередь событий треда GUI.

К сожалению, GLFW использует глобальные переменные для своих колбеков, и в
документации точно не определено, изнутри каких функций могут быть вызваны эти колбеки,
что расширяет требуемое время жизни получателей событий до бесконечности.

Оконный менеджер выпрямляет это, реализуя API, где указатели на получатели событий
передаются только на время работы функции get events.

Указатель на реальный получатель события хранится в полях окна. Он устанавливается
при входе в get events и сбрасывается при выходе из неё.

Колбеки GLFW устанавливаются заранее при инициализации.
GLFW предоставляет вызванному колбеку указатель на окно. Код колбека проверяет
в экземпляре окна указатель на реальный получатель этого типа событий, и,
если он не равен нулю, вызывает его. Если указатель равен нулю, колбек ничего
не делает, но генерирует прерывание отладчика, чтобы отслеживать
нежелательное поведение.

Ещё один сомнительный колбек GLFW — это обработчик ошибок. В случае возникновения
ошибки, GLFW иногда возвращает ошибку в значении функции, но зачастую не возвращает
её нигде и лишь вызывает глобальный колбек.

Реализация этого колбека в оконном менеджере сохраняет сообщение об ошибке
в глобальной строке. После вызова функции GLFW, вызывающий код всегда
проверяет эту строку на наличие ошибок.

Порядок инициализации
=====================

Существуют такие зависимости:

* Обменник GUI владеет буфером картинки в памяти GPU, что невозможно без контекста
  GPU. При создании обменника буфер пустой, поэтому контекст GPU не требуется.
  Однако уничтожение обменника GUI должно быть раньше, чем уничтожение контекста
  GPU.

* Уведомитель потока GUI можно создать до создания окна, но лишь после
  инициализации оконного менеджера (GLFW), так как он будит тред GUI
  с помощью функции GLFW, кладущей пустое событие в очередь событий.

* OpenGL появляется только после создания окна. Поэтому создание разделяемого
  буфера CUDA/OpenGL возможно только после создания окна.

Текущий порядок инициализации:

* Создаёт все подсистемы: GuiClass, Worker, ConfigKeeper и
  LogKeeper. Их треды пока не запущены.

* Инициализирует ConfigKeeper. Загружает конфиг и обновляет переменные
  всех подсистем.

* Создаёт все обменники: guiService, workerService, configService и
  logService.

* Инициализирует и запускает тред LogKeeper. Запускает тред ConfigKeeper.

* Создаёт контекст GPU и стримы GPU для тредов GUI и WORKER.

* Создаёт оконный менеджер (GLFW).

* Создаёт уведомитель треда GUI и устанавливает его для обменника GUI.

* Инициализирует и запускает тред WORKER.

* Дальше работает цикл повторного создания окна. При создании окна
  создаётся контекст OpenGL. Окно можно пересоздавать без пересоздания
  контекста GPU, несмотря на интероп CUDA/OpenGL.

* После того, как окно создано, доступен OpenGL. Создаёт рисователь окна
  PixelBufferDrawing, в том числе компилирует его шейдеры.

* Создаёт буфер изображения окна, разделяемый между CUDA и OpenGL. Размер этого буфера
  может меняться в течение работы программы.
