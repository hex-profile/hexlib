[EN](README.md) RU

Оглавление
==========

* [Взаимодействие тредов](#взаимодействие-тредов)
* [Обновления и понятие дельта-буфера](#обновления-и-понятие-дельта-буфера)
* [API дельта-буфера](#api-дельта-буфера)
* [Обменник](#обменник)
* [Избежание реаллокаций при обмене](#избежание-реаллокаций-при-обмене)
* [Треды и использование GPU](#треды-и-использование-gpu)

Взаимодействие тредов
=====================

Все треды взаимодействуют по абсолютно одинаковой схеме.

Каждый тред работает как сервис, который в цикле ожидает, получает и обрабатывает
обновления.

Получается схема, где есть несколько производителей обновлений и лишь один
потребитель обновлений – сам тред.

Все треды совершенно равноправные и могут обслуживать друг друга.

Например, пользователь даёт команду редактирования конфига, тред GUI отправляет
задание на редактирование треду ConfigKeeper. Тот запускает редактор и
ожидает его завершения, затем отправляет обновление конфига треду GUI,
который обновляет свои переменные и пересылает обновление конфига треду WORKER.
При этом и ConfigKeeper, и WORKER могут печатать текстовые сообщения, которые
являются обновлениями для треда GUI.

Обновления и понятие дельта-буфера
==================================

У каждого треда есть несколько типов принимаемых обновлений. Например, тред GUI
принимает обновления глобальной текстовой консоли, локальной текстовой консоли,
картинки и так далее. Запрос на завершение треда – это тоже один из типов
обновлений.

Для каждого типа обновлений существует класс так называемого дельта-буфера,
буфера изменений. Дельта-буфер содержит изменения, которые можно приложить к
другому такому же буферу.

Например, в случае буфера "текстовая консоль", клиент может захотеть напечатать
несколько сообщений. Он отправляет серверу дельта-буфер, содержащий эти
несколько сообщений, сервер получает их и добавляет к своему дельта-буферу,
который хранит текущее состояние консоли.

Обновление не всегда означает добавление. Например, клиент может захотеть
очистить консоль и затем напечатать сообщения. Тогда он отправляет дельта-буфер,
содержащий запрос на очистку и сообщения. Когда сервер получит и добавит этот
буфер к своему текущему буферу, текущий буфер будет очищен перед добавлением
сообщений, как будто клиент обновлял текущий буфер напрямую.

Классы дельта-буферов лежат в каталоге `/channels/buffers`.

API дельта-буфера
=================

* `hasUpdates`: Проверяет наличие обновлений. Например, если текстовая
консоль была очищена клиентом, этот буфер НЕ пуст, так как он содержит
обновление "очистить консоль".
* `reset`: Очищает буфер. Не освобождает память.
* `absorb`: Добавляет изменения из другого буфера, одновременно очищая другой буфер.
Не освобождает память другого буфера.
* `moveFrom`: Заменяет содержимое содержимым другого буфера и очищает другой буфер.
Не освобождает память буферов.
* `clearMemory`: Очищает буфер и освобождает память.

Обменник
========

Обмен с каждым из сервисов осуществляется через так называемый обменник. В коде
он называется board.

Обменник содержит внутри себя мьютекс и разделяемую память, защищенную этим
мьютексом: по одному буферу для каждого типа буфера данного сервиса.

Обменник предоставляет два API, для клиента и для сервера.

Для клиента API всегда выглядит как "добавить буфер". Буфер клиента добавляется
к разделяемому буферу. Часто разделяемый буфер пустой, так как сервер уже всё
обработал и ждет — тогда буфер клиента быстро заменяет разделяемый буфер.

Для сервера API всегда выглядит как "забрать буфер". Сервер забирает буфер
целиком и опустошает разделяемый буфер.

Клиент может добавлять один тип буфера или все буферы сразу. Сервер обычно
забирает сразу все буферы.

Функция сервера "забрать буфер" ждёт появления непустого разделяемого буфера.
В некоторых сервисах может указываться флаг ожидания
и таймаут ожидания в миллисекундах.

Когда клиент добавляет буфер, обменник будит сервер. Для обычных тредов это
сделано через condition_variable, а для треда GUI передаётся callback
уведомителя. В случае GLFW он кладет специальное пустое событие в очередь
событий.

Обменники лежат в каталоге `/channels`.

Избежание реаллокаций при обмене
================================

Для избежания постоянных реаллокаций буферов используется схема с обменом
буферов. Все буферы, участвующие в постоянном обмене, существуют постоянно и
не удаляются, включая собственные буферы клиента и сервера, а также
разделяемые буферы.

Когда клиент добавляет собственный буфер, он отдает собственный буфер по
ссылке. После добавления к разделяемому буферу, собственный буфер опустошается,
но его память не освобождается.

Точно так же это работает, когда сервер забирает разделяемый буфер в свой
собственный буфер. Разделяемый буфер опустошается, но его память не
освобождается. Это аналогично move семантике, но с гарантированным
опустошением исходного буфера.

В основном пересылки буферов являются быстрыми операциями обмена и опустошения,
без освобождения памяти. Исключение составляет лишь случай, когда сервер не
успевает обрабатывать задания, тогда буфер клиента действительно добавляется к
непустому разделяемому буферу. Но даже в этом случае сами элементы буфера
переносятся.

Треды и использование GPU
=========================

В графической оболочке только два треда используют GPU: GUI и WORKER.

Оба треда используют один и тот же общий контекст GPU, но каждый тред имеет свой
собственный стрим GPU (очередь команд).

Внешняя оболочка создает контекст GPU и оба стрима GPU в процессе инициализации.

## Поддержка инструментов GPU модуля

Как тред WORKER, так и тред GUI создают полную поддержку GPU-модуля hexlib с
помощью `MinimalShell`:

* Тред WORKER вызывает целевой тестовый модуль, поэтому требует полный набор
  инструментов GPU-модуля.

* Тред GUI выполняет на GPU рисование графического интерфейса, что можно было
  сделать более простыми средствами, но я решил дать полную поддержку
  GPU-модуля, так как при развитии графического интерфейса могут понадобиться
  хорошие средства визуализации и профилирования.

## Дельта-буфер для обмена GPU картинкой

Дельта-буфер постоянно передается между тредами, поэтому обычные аллокаторы
hexlib не подходят, и вместо этого используется прямое выделение памяти
базовыми функциями GPU.

Эти функции медленные и вызывают полную синхронизацию всего на GPU. Поэтому
буфер работает по жадному принципу: при изменении размера картинки, память
реаллоцируется лишь в случае, когда ранее выделенного объема памяти
недостаточно.

Доступ к данным картинки происходит так: тред WORKER записывает данные
картинки кернелом GPU, после чего владение буфером передается треду GUI, который
при операциях перерисовки один или несколько раз считывает картинку, также
кернелом GPU.

GPU работает асинхронно с CPU, поэтому возникает вопрос синхронизации. Для
этого каждый буфер содержит два евента GPU: один означает завершение записи
в буфер, а другой — завершение чтения из буфера.

Каждый из тредов перед обращением к памяти буфера вставляет в свой стрим GPU
команду подождать евента завершения чужой операции, а после работы с памятью
буфера, записывает евент завершения своей операции.

Таким образом достигается гладкая состыковка двух стримов GPU, без
неэффективных синхронизаций на CPU. Единственное исключение составляет
увеличение размера картинки, которое вызывает реаллокацию памяти GPU: в
этом случае функции аллокации полностью синхронизируют весь контекст GPU.

NVIDIA предлагает думать об евенте как об объекте, который содержит множество
работы, записанной на некоторый момент в некотором стриме GPU. Операция
ожидания евента ждет, пока вся эта работа будет выполнена. После создания
евента это множество пустое, поэтому ожидание такого евента сразу
заканчивается. Если повторно записывать в тот же евент, новое множество
работы заменяет старое множество. Например, тред GUI может несколько раз
считывать данные картинки при перерисовке, многократно перезаписывая евент
завершения чтения.
