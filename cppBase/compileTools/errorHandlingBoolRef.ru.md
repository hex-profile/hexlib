[EN](errorHandlingBoolRef.en.md) RU

# Режим обработки ошибок с использованием ссылки на булевский флаг

Этот метод обработки ошибок работает через протягивание ссылки на булевский флаг
между функциями.

Он содержит спорные решения, но приводит к более чистому и короткому прикладному
коду, похожему на тот, который достигается при использовании исключений.

Фактически этот режим является запасным вариантом компиляции, если исключения
по каким-то причинам нельзя использовать.

## Отличие от традиционного подхода hexlib

Данный метод обработки ошибок не требует заключать каждый вызов фунции в макрос
проверки ошибки `require`, что было особенно неудобным для больших вызовов:

```
require
(
    kit.gpuImageConsole.addMatrixEx
    (
        rawImage,
        float32(typeMin<MonoPixel>()),
        float32(typeMax<MonoPixel>()),
        point(1.f), INTERP_NONE, rawImageSize, BORDER_ZERO,
        paramMsg(STR("View %, Raw Input"), args.displayedView),
        stdPass
    )
);
```

## Как это работает

Каждая функция, помимо стандартного набора параметров (kit, callstack,
профайлер) получает внутри `stdPars` дополнительную ссылку на булевский флаг.

Флаг изначально создаётся со значением `true` (при создании корневых
"стандартных параметров") и при нормальном течении исполнения программы всегда
остаётся равным `true`.

Флаг передаётся между функциями по ссылке. Если в функции возникает ошибка, она
устанавливает флаг в `false` и делает `return`. Вызывающая функция проверяет
флаг и, если он сброшен, также делает `return`.

## Макрос `stdPass` и его особенности

Макрос стандартной передачи параметров `stdPass*` в этом режиме обработки ошибок
становится "очень плохим макросом (тм)". Он:

* Закрывает скобку вызова функции;

* Выполняет проверку флага успеха, и, если флаг сброшен, делает `return`
из функции;

* Заканчивается чем-то вида `do {...} while (0`, так что пользовательский код
может закрыть скобку вызова функции и `stdPass` выглядит просто как последний
параметр функции.

## Возможные проблемы и их обход

Этот подход устраняет boilerplate проверок возврата, но имеет побочные эффекты.
В частности, макрос `stdPass*` уже не является единым целым и разделяет вызов
функции на два оператора.

В результате, если вызов функции стоит под условным оператором или оператором
цикла, может выполниться только первая часть макроса, а проверка будет выполнена
уже после оператора.

На первый взгляд кажется, что это ставит крест на данном методе. Однако всё
не так плохо.

В случае конструкции `if+else`, компилятор требует использовать фигурные скобки,
выдавая ошибку ещё на этапе компиляции.

В случае одиночного `if`, такое место действительно пропускается компилятором,
при этом проверка флага выполняется всегда, независимо от условия,
что не нарушает логику работы, но может привести к исполнению двух-трёх лишних
ассемблерных команд.

Для выявления проблемных мест с циклами существует скрипт на Python, функция
`check_issues_in_bool_ref_error_mode`.
